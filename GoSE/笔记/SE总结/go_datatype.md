基本类型：
整型：[u]int[数字]：有u代表无符号，范围为0到2的数字方-1.有符号范围为：负的2的（数字-1）次方到2的（数字-1）次方-1.
    注意点；uint	32位操作系统上就是uint32，64位操作系统上就是uint64
int	32位操作系统上就是int32，64位操作系统上就是int64.在使用int和 uint类型时，不能假定它是32位或64位的整型，而是考虑int和uint可能在不同平台上的差异。

浮点型：Go语言支持两种浮点型数：float32和float64

布尔型：ture和false
    注意点：布尔类型变量的默认值为false。
        Go 语言中不允许将整型强制转换为布尔型.
        布尔型无法参与数值运算，也无法与其他类型进行转换。

字符串：在golang中，字符串是字节的集合。Go 中的字符串是兼容 Unicode 编码的，并且使用 UTF-8 进行编码。所以字符串是一个字节切片。但放眼国际，有很多语言的一个单词编码超过一个字节，我们就不能用byte类型，要用rune类型，int32的别称，也是go的内建类型。rune代表一个代码点，这个代码点无论占用多少个字节，都可以用一个rune来表示
        uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。
        rune类型，代表一个 UTF-8字符
    求字符串长度：utf8 package 包中的 func RuneCountInString(s string) (n int) 方法用来获取字符串的长度。这个方法传入一个字符串参数然后返回字符串中的 rune 的数量。
    遍历字符串：rune两种方法:1.先转换为rune切片：for:len()  2.for range
    修改字符串：把字符串转化为一个 rune 切片。然后这个切片可以进行任何想要的改变，然后再转化为一个字符串。
    构造字符串：用rune切片构造

类型转换：强制类型转换：type(表达式)


高级类型：
    数组：同一数据类型元素的集合，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变：[2]int和[3]int是两个不同类型数组

    初始化方式：1.初始化列表 2. 编译器自行推断数组长度进行初始化 3. 结合2来指定索引值初始化
    遍历方式：1.for :len  2. for range
    多维数组：注意点： 多维数组只有第一层可以使用...来让编译器推导数组长度
    注意点：数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。

    切片：切片（Slice）是一个拥有相同类型元素的可变长度的序列，是对底层数组的引用，所以是引用类型数据，内部结构实际是一个结构体，包含地址，长度，容量。
    声明：var name []T
    初始化(构造)方式：1 .var name= []T{}
    构造切片：切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片
            1.简单切片表达式：数组：a[low,high],得到的切片长度=high-low，容量等于得到的切片的底层数组的容量。
                            切片：a[low,high],high的上限边界是切片的容量cap(a)，而不是长度。
            2.数组，指向数组的指针，或切片a(注意不能是字符串)支持完整切片表达式:a[low : high : max],它会将得到的结果切片的容量设置为max-low,0 <= low <= high <= max <= cap(a)
            3.make([]T, size, cap),容量是可选参数, 默认值为切片长度。make 函数创建一个数组，并返回引用该数组的切片。使用 make 创建切片时默认情况下这些值为零
    长度和容量：通过使用内置的len()函数求长度，使用内置的cap()函数求切片的容量。
    切片遍历：和数组一样
    切片的修改{切片自己不拥有任何数据。它只是底层数组的一种表示。对切片所做的任何修改都会反映在底层数组中。}：
                1.添加：append，可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）
                        注意点：：通过var声明的零值切片可以在append()函数直接使用来添加元素，无需初始化。
                                每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略（翻倍）进行“扩容”（切片扩容还会根据切片中元素的类型不同而做不同的处理，比如int和string类型的处理方式就不一样。），扩容后底层数组又是一个全新的了
               2.内存优化：切片持有对底层数组的引用。只要切片在内存中，数组就不能被垃圾回收。在内存管理方面，这是需要注意的。让我们假设我们有一个非常大的数组，我们只想处理它的一小部分。然后，我们由这个数组创建一个切片，并开始处理切片。这里需要重点注意的是，在切片引用时数组仍然存在内存中。一种解决方法是使用 copy 函数 func copy(dst，src[]T)int 来生成一个切片的副本。这样我们可以使用新的切片，原始数组可以被垃圾回收
               切片的复制：copy(destSlice, srcSlice []T)
               3.删除元素：要从切片a中删除索引为index的元素，操作方法是a = append(a[:index], a[index+1:]...){注意点：删除的实质是底层数组如何在变化}
               4.切片作为函数参数传递：当切片传递给函数时，即使它通过值传递，指针变量也将引用相同的底层数组。因此，当切片作为参数传递给函数时，函数内所做的更改也会在函数外{因为底层数组可能会改变了}可见
    注意点：判断切片为空不能用nil,用len(切片)==0来判断


    map:
    map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。map类型的变量默认初始值为nil，需要使用make()函数来分配内存{也就是初始化了}
    初始化 方式:1.make(map[KeyType]ValueType, [cap])，cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量  2.声明时通过值列表初始化
    判断某个键是否存在：value, ok := map[key]
    遍历：for range{注意点：遍历map时的元素顺序与添加键值对的顺序无关}
    删除：delete(map, key)
    获取map长度：len函数
    判断两map相等：不能用==，只能遍历比较。==只能检查map是否为nil

    指针：{注意点：指针不能进行偏移和运算，不要向函数传递数组的指针，而应该使用切片}
    定义：任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。
    概念：指针地址，指针类型，指针取值
    new:new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值.var a *int只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了
    make:make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了
        {二者都是用来做内存分配的。
    make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；
    而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。
    }

    函数：（一等公民）
        定义：func 函数名（参数名1，参数名2 前两者类型1，参数名3 类型2，可变参数名 ...类型3）(返回值列表（多返回值也可以结合返回值命名）){注意点：：可变参数通常要作为函数的最后一个参数，本质上，函数的可变参数是通过切片来实现的（比如append函数的实现）  当返回值类型为slice，可以直接返回nil}
        变量作用域：1 全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。2 局部变量：函数内定义的变量无法在该函数外使用，局部变量和全局变量重名，优先访问局部变量  3 语句块定义的变量只在语句块内作用

        头等函数（用途是什么？？？头等函数可以很轻松地实现。我们把这种对集合中的每个元素进行操作的函数称为 map 函数。）：支持头等函数（First Class Function）的编程语言，可以把函数赋值给变量，也可以把函数作为其它函数的参数或者返回值。Go 语言支持头等函数的机制。
            用户自定义函数类型与变量：type 类型名 func(参数列表)（返回值列表）
            作为其他函数参数
            作为其他函数返回值
        匿名函数：由于go语言内部中不能像之前那样定义函数，只能定义匿名函数，即没有函数名的函数。所以不能像普通函数那样调用：1.保存到某个变量 2.立即执行函数
        闭包：。当一个匿名函数所访问的变量定义在函数体的外部时，就称这样的匿名函数为闭包。闭包=匿名函数+引用环境

        defer:{执行时机，defer后面函数含参数要先确定参数}

        panic/recover:????{recover()必须搭配defer使用。
    defer一定要在可能引发panic的语句之前定义。}

        方法：方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self。方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。
        定义：func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) {
                函数体
            }{官方建议使用接收者类型名称首字母的小写，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。
            接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。
            方法名、参数列表、返回参数：具体格式与函数定义相同。}
        分类：1.指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的 2.当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身{注意点：需要修改接收者中的值
接收者是拷贝代价比较大的大对象
保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。}



    结构体：{结构体占用一块连续的内存。}
    自定义类型：type 新类型名 {基础类型名组合} 新类型名是一种新的类型，具有 {基础类型名组合} 的特性
    类型别名 type byte=uint8  type rune=int32{小名}
    {两者区别：自定义类型只会在代码中存在，编译完成时不会有了}

    Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。 也就是我们可以通过struct来定义自己的类型了。
    Go语言中通过struct来实现面向对象。
    定义：type 类型名 struct {
    字段名1，字段名2 字段类型
    字段名3 字段类型
    …
}
    实例化；只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。1.值列表实例化 2.new关键字对结构体进行实例化，得到的是结构体的地址 3.&对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作。
    当定义好的结构体并没有被显式地初始化时，该结构体的字段将默认赋为零值。
    初始化：1.键值对列表初始化 2.结构体指针 3.值列表初始化{必须初始化结构体的所有字段。
初始值的填充顺序必须与字段在结构体中的声明顺序一致。
该方式不能和键值初始化方式混用。}

    匿名结构体：var 变量名 struct{列表}

    结构体构造函数{结构体取代类}：如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。

    结构体匿名字段：结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。{这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。}

    嵌套结构体{组合取代继承}(嵌套的结构体可以采用匿名字段方式，可能产生冲突，逐步引用来解决)：一个结构体中可以嵌套包含另一个结构体或结构体指针。也实现了结构体的继承




    接口{实现多态}：一组method的集合，一种抽象的类型。{接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。}
    定义格式：type 接口类型名 interface{
    方法名1( 参数列表1 ) 返回值列表1
    方法名2( 参数列表2 ) 返回值列表2
    …
}{Go语言的接口在命名时，一般会在单词后面添加er，当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。}
    实现接口条件：一个对象只要全部实现了接口中的方法，那么就实现了这个接口。
    接口类型变量：接口类型变量能够存储所有实现了该接口的实例
    使用值接收者和指针接收者实现接口的区别：1.值接收者实现接口之后，不管是dog结构体还是结构体指针*dog类型的变量都可以赋值给该接口变量。。因为Go语言中有对指针类型变量求值的语法糖，dog指针fugui内部会自动求值*fugui。2.使用指针接收者实现接口时，只能是结构体指针类型的变量可以赋值给该接口变量
    类型与接口关系：一个类型可以实现多个接口  多个类型可以实现同一接口
    接口嵌套：传造出新接口
    空接口：空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。空接口类型的变量可以存储任意类型的变量。{空接口作为函数的参数
使用空接口实现可以接收任意类型的函数参数。{空接口作为map的值，使用空接口实现可以保存任意值的字典。}
接口断言:{空接口可以存储任意类型的值，那我们如何获取其存储的具体数据呢？}:x.(T){x：表示类型为interface{}的变量
T：表示断言x可能是的类型。}该语法返回两个参数，第一个参数是x转化为T类型后的变量，第二个值是一个布尔值，若为true则表示断言成功，为false则表示断言失败。




   
        